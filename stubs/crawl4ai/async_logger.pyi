import abc
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from enum import Enum

class LogLevel(Enum):
    DEFAULT = 0
    DEBUG = 1
    INFO = 2
    SUCCESS = 3
    WARNING = 4
    ERROR = 5
    CRITICAL = 6
    ALERT = 7
    NOTICE = 8
    EXCEPTION = 9
    FATAL = 10

class LogColor(str, Enum):
    DEBUG = 'bright_black'
    INFO = 'cyan'
    SUCCESS = 'green'
    WARNING = 'yellow'
    ERROR = 'red'
    CYAN = 'cyan'
    GREEN = 'green'
    YELLOW = 'yellow'
    MAGENTA = 'magenta'
    DIM_MAGENTA = 'dim magenta'
    RED = 'red'

class AsyncLoggerBase(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def debug(self, message: str, tag: str = 'DEBUG', **kwargs): ...
    @abstractmethod
    def info(self, message: str, tag: str = 'INFO', **kwargs): ...
    @abstractmethod
    def success(self, message: str, tag: str = 'SUCCESS', **kwargs): ...
    @abstractmethod
    def warning(self, message: str, tag: str = 'WARNING', **kwargs): ...
    @abstractmethod
    def error(self, message: str, tag: str = 'ERROR', **kwargs): ...
    @abstractmethod
    def url_status(self, url: str, success: bool, timing: float, tag: str = 'FETCH', url_length: int = 100): ...
    @abstractmethod
    def error_status(self, url: str, error: str, tag: str = 'ERROR', url_length: int = 100): ...

class AsyncLogger(AsyncLoggerBase):
    DEFAULT_ICONS: Incomplete
    DEFAULT_COLORS: Incomplete
    log_file: Incomplete
    log_level: Incomplete
    tag_width: Incomplete
    icons: Incomplete
    colors: Incomplete
    verbose: Incomplete
    console: Incomplete
    def __init__(self, log_file: str | None = None, log_level: LogLevel = ..., tag_width: int = 10, icons: dict[str, str] | None = None, colors: dict[LogLevel, LogColor] | None = None, verbose: bool = True) -> None: ...
    def debug(self, message: str, tag: str = 'DEBUG', **kwargs): ...
    def info(self, message: str, tag: str = 'INFO', **kwargs): ...
    def success(self, message: str, tag: str = 'SUCCESS', **kwargs): ...
    def warning(self, message: str, tag: str = 'WARNING', **kwargs): ...
    def critical(self, message: str, tag: str = 'CRITICAL', **kwargs): ...
    def exception(self, message: str, tag: str = 'EXCEPTION', **kwargs): ...
    def fatal(self, message: str, tag: str = 'FATAL', **kwargs): ...
    def alert(self, message: str, tag: str = 'ALERT', **kwargs): ...
    def notice(self, message: str, tag: str = 'NOTICE', **kwargs): ...
    def error(self, message: str, tag: str = 'ERROR', **kwargs): ...
    def url_status(self, url: str, success: bool, timing: float, tag: str = 'FETCH', url_length: int = 100): ...
    def error_status(self, url: str, error: str, tag: str = 'ERROR', url_length: int = 50): ...

class AsyncFileLogger(AsyncLoggerBase):
    log_file: Incomplete
    def __init__(self, log_file: str) -> None: ...
    def debug(self, message: str, tag: str = 'DEBUG', **kwargs): ...
    def info(self, message: str, tag: str = 'INFO', **kwargs): ...
    def success(self, message: str, tag: str = 'SUCCESS', **kwargs): ...
    def warning(self, message: str, tag: str = 'WARNING', **kwargs): ...
    def error(self, message: str, tag: str = 'ERROR', **kwargs): ...
    def url_status(self, url: str, success: bool, timing: float, tag: str = 'FETCH', url_length: int = 100): ...
    def error_status(self, url: str, error: str, tag: str = 'ERROR', url_length: int = 100): ...
