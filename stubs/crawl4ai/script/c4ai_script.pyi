import pathlib
from _typeshed import Incomplete
from dataclasses import dataclass
from lark import Transformer
from lark.exceptions import VisitError as VisitError
from typing import Any

class C4AScriptError(Exception):
    message: Incomplete
    line: Incomplete
    column: Incomplete
    error_type: Incomplete
    details: Incomplete
    def __init__(self, message: str, line: int = None, column: int = None, error_type: str = 'Syntax Error', details: str = None) -> None: ...
    @classmethod
    def from_exception(cls, exc: Exception, script: str | list[str]) -> C4AScriptError: ...

GRAMMAR: str

@dataclass
class Cmd:
    op: str
    args: list[Any]

@dataclass
class Proc:
    name: str
    body: list[Cmd]

class ASTBuilder(Transformer):
    def start(self, *i): ...
    def line(self, i): ...
    def command(self, i): ...
    def wait_cmd(self, rest, timeout=None): ...
    def go(self, u): ...
    def reload(self): ...
    def back(self): ...
    def forward(self): ...
    def click(self, *args): ...
    def double_click(self, *args): ...
    def right_click(self, *args): ...
    def coords(self, x, y): ...
    def move(self, c): ...
    def drag(self, c1, c2): ...
    def scroll(self, dir_tok, amt=None): ...
    def type(self, tok): ...
    def clear(self, sel): ...
    def set_input(self, sel, val): ...
    def press(self, w): ...
    def key_down(self, w): ...
    def key_up(self, w): ...
    def eval_cmd(self, txt): ...
    def setvar(self, n, v): ...
    def proc_call(self, n): ...
    def proc_def(self, n, *body): ...
    def include(self, p): ...
    def comment(self, *_): ...
    def if_cmd(self, condition, then_cmd, else_cmd=None): ...
    def condition(self, cond): ...
    def not_cond(self, cond): ...
    def exists_cond(self, selector): ...
    def js_cond(self, expr): ...
    def repeat_cmd(self, cmd, count): ...
    def repeat_count(self, value): ...

class Compiler:
    parser: Incomplete
    root: Incomplete
    vars: dict[str, Any]
    procs: dict[str, Proc]
    def __init__(self, root: pathlib.Path | None = None) -> None: ...
    def compile(self, text: str | list[str]) -> list[str]: ...

def compile_string(script: str | list[str], *, root: pathlib.Path | None = None) -> list[str]: ...
def compile_file(path: pathlib.Path) -> list[str]: ...
def compile_lines(lines: list[str], *, root: pathlib.Path | None = None) -> list[str]: ...

DEMO: str
