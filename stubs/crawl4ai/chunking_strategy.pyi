import abc
from _typeshed import Incomplete
from abc import ABC, abstractmethod

class ChunkingStrategy(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def chunk(self, text: str) -> list: ...

class IdentityChunking(ChunkingStrategy):
    def chunk(self, text: str) -> list: ...

class RegexChunking(ChunkingStrategy):
    patterns: Incomplete
    def __init__(self, patterns=None, **kwargs) -> None: ...
    def chunk(self, text: str) -> list: ...

class NlpSentenceChunking(ChunkingStrategy):
    def __init__(self, **kwargs) -> None: ...
    def chunk(self, text: str) -> list: ...

class TopicSegmentationChunking(ChunkingStrategy):
    tokenizer: Incomplete
    num_keywords: Incomplete
    def __init__(self, num_keywords: int = 3, **kwargs) -> None: ...
    def chunk(self, text: str) -> list: ...
    def extract_keywords(self, text: str) -> list: ...
    def chunk_with_topics(self, text: str) -> list: ...

class FixedLengthWordChunking(ChunkingStrategy):
    chunk_size: Incomplete
    def __init__(self, chunk_size: int = 100, **kwargs) -> None: ...
    def chunk(self, text: str) -> list: ...

class SlidingWindowChunking(ChunkingStrategy):
    window_size: Incomplete
    step: Incomplete
    def __init__(self, window_size: int = 100, step: int = 50, **kwargs) -> None: ...
    def chunk(self, text: str) -> list: ...

class OverlappingWindowChunking(ChunkingStrategy):
    window_size: Incomplete
    overlap: Incomplete
    def __init__(self, window_size: int = 1000, overlap: int = 100, **kwargs) -> None: ...
    def chunk(self, text: str) -> list: ...
